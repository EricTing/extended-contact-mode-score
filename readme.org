* eXtended Contact Mode Score (xCMS)
Extend the application of Contact Mode Score to non-identical complexes

** Methods
1. Contact Matrix
   1. Corresponding residues of two binding pockets
      1. [X] <<<subject>>>
         1. [X] Ligands of two pockets have a Tc >= 0.5
         2. [X] Sequence similarity < 30% between the two associated proteins
         3. [X] shaore >= 50 atmic ligand-protein contacts of same type
         4. [X] the pdb files provided by Apoc contains only C_alpha atoms
   2. [X] coordinates of the effective points
      1. use the pdb files downloaded from PDB to grep the proteins' residues
      2. use the mixed resolution as in the CMS
      3. use the <<<virtual effective>>> points to compensate for miss-matched residues
         1. the contact between a ligand atom and a virtual effective point is always *None*
      4. [X] retrieve the ligand from mmCIF file and convert to mol2 format
         1. [X] can tag such as "3zyc_GCP_A_1749" uniquely identify a ligand from the pdb file?
            Yes, but it is not safe to do so in a pdb file
         2. [X] check out
            1. [X] Python PDBx
            2. [X] BioPython
            3. [X] OpenBabel c++ library
               1. residue names become "LIG" when read by babel
               2. [X] how babel parse the mmCIF file?
                  hacked the parser in babel for mmCIF in ordr to retrieve auth* fields
   3. [ ] certain ligands cannot be grepped
      e.g. 3q2k_NAD_P_500
   4. [ ] certain pdbs miss some atoms
      1. in /ddnB/work/jaydy/dat/pdb/vn/pdb3vn9.ent
         | ATOM | 674 | N  | GLU | A | 130 | -2.316 | -44.226 | 2.992 | 1.00 |  90.63 | N |
         | ATOM | 675 | CA | GLU | A | 130 | -1.581 | -44.192 | 4.257 | 1.00 |  83.49 | C |
         | ATOM | 676 | C  | GLU | A | 130 | -1.888 | -42.913 | 5.017 | 1.00 | 100.53 | C |
         | ATOM | 677 | O  | GLU | A | 130 | -2.031 | -41.844 | 4.392 | 1.00 |  97.24 | O |
         | ATOM | 678 | CB | GLU | A | 130 | -0.072 | -44.310 | 4.027 | 1.00 |  73.44 | C |
      2. in /ddnB/work/jaydy/dat/pdb/t9/pdb3t9a.ent
         | ATOM | 1612 | N   | GLU | A | 238 |  8.315 | -2.250 | 6.872 | 1.00 | 21.85 | N |
         | ATOM | 1613 | CA  | GLU | A | 238 |  9.731 | -2.356 | 7.160 | 1.00 | 23.40 | C |
         | ATOM | 1614 | C   | GLU | A | 238 | 10.257 | -0.984 | 7.551 | 1.00 | 23.08 | C |
         | ATOM | 1615 | O   | GLU | A | 238 |  9.910 |  0.026 | 6.922 | 1.00 | 22.77 | O |
         | ATOM | 1616 | CB  | GLU | A | 238 | 10.506 | -2.904 | 5.947 | 1.00 | 23.90 | C |
         | ATOM | 1617 | CG  | GLU | A | 238 | 10.539 | -1.968 | 4.735 | 1.00 | 27.61 | C |
         | ATOM | 1618 | CD  | GLU | A | 238 | 11.471 | -2.450 | 3.608 | 1.00 | 32.44 | C |
         | ATOM | 1619 | OE1 | GLU | A | 238 | 12.400 | -3.248 | 3.888 | 1.00 | 35.07 | O |
         | ATOM | 1620 | OE2 | GLU | A | 238 | 11.268 | -2.020 | 2.448 | 1.00 | 32.92 | O |
      3. problem resolved if by using virtual effective points
   5. list file from apoc contains weird keys words such as "### XYM 35"
      1. original
         /ddnB/work/jaydy/dat/apoc/RS2.lst
      2. cleaned
         /work/jaydy/dat/apoc/RS2_valid.lst
   6. Corresponding heavy atoms of two ligands
      1. Kcombu (currently used)
      2. SIMCOMP (used in Apoc paper)
         <<<SIMCOMP>>> tend to yield higher Tc than <<<pkcombu>>>

** Pipeline
1. Original pdb file for the complex
   1. apoc_inputs.PdbPathTask
   2. apoc_inputs.DecompressedPdb
2. Grep Ligand atoms from the pdb
   1. apoc_inputs.LigandExpStructureInPdb
3. Run apoc
   1. run_control_apoc.LpcApocResultTask
4. Run kcombu
   1. run_control_apoc.LpcKcombuResult
5. Parsers
   1. run_control_apoc.ApocResultParer
   2. run_control_apoc.PkcombuAtomMatchParser
6. Run xcms
   1. xcms.LpcApocXcms
7. Collect data for analysis
   1. collect_xcms.AtomicXcmsCollection
   2. collect_xcms.AtomicXcmsTable

** [#A] xCms back compatible with Cms
The value of xCms should be <<<back-compatible>>> with Cms.
1. materials
   complexes in the Astext dataset
2. methods
   1. apply rotation and translation to each ligand
      1. to calculate Cms for each complex
         1. calculate the Cms between the variational conformations and the native conformation
      2. to calculate xCms for eac complex
         1. find the neighboring residues in contact with ligand atoms
         2. align the neighboring residues using Apoc
         3. for the matching residues from Apoc, add virtual points
         4. calculate the xCms between the variational conformations and the native conformation

** [#A] Statistical significance of cms
1. run MC for each complex in astex with weak constraints
   1. vdw * 0.5
2. cluster the conformations based on their translational and rotational vector
   1. [X] experiment with DBSCAN
      1. do not use DBSCAN becuase it removes the outliers
   2. [X] experiment with KMeans
      1. Kmeans maintain the density distribution as the original ponts
   3. experiment with the grid method
      1. [X] grid method provides evenly distributed points
3. calculate pair-wise p-value
4. sample
   1. [X] stratefied sampling
      Assume that the # of grid cells is n,
      the # of samples from each complex is \propto to n^2
5. [ ] analyze the distribution of the cms values
   

** [#B] Statistical significance of xcms value
*** Run on a random dataset
1. Random set (<<<RS2>>>) from Apoc
   /ddnB/work/jaydy/dat/apoc/RS2.lst
   /ddnB/work/jaydy/dat/apoc/RS2_valid.lst
2. script
   ./src/run_lpc_randomset.py
3. [X] run time errors
   Cannot do much about the errors below because of the in-perfection of the source of data.
   1. missing pdb files
      /ddnB/work/jaydy/dat/apoc/missing_pdbs.txt
   2. protein pairs that have mis-matched elements
      /ddnB/work/jaydy/dat/apoc/mis_matched_prt.txt
   3. kcombu failures
      /ddnB/work/jaydy/dat/apoc/kcombu_failures.txt
4. [ ] curate <<<dataset>>>
   1. [ ] calculate the all-against-all apoc, kcombu using the successful pockets dataset
   2. [ ] cluster using DBSCAN based on the ps-score and Tc between two pockets
      1. \sqrt{ps-score^2 + Tc^2} --> similarity
      2. or use the product directly
      3. similarity(ps-score = 0.4, Tc = 0.4) --> eps
   3. [ ] use the centroids' xcms to calculate the statistical significance
5. curate subject
   ./src/curate.py
   ./src/run_curate.py
   1. dbscan for subject dataset
      |  eps | #clusters |
      |------+-----------|
      |  1.0 |      1070 |
      |  1.1 |       764 |
      | 1.15 |       620 |
      |  1.2 |       406 |
      |  1.3 |       103 |
